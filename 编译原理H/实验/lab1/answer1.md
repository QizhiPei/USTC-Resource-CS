## **问题1-1**： 如果在命令行下执行  `gcc -DNEG -E sample.c -o sample.i` 生成的`sample.i` 与之前的有何区别？

* 定义了预处理宏`NEG`,因而`M`被定义为-4

## **问题1-2** 请对比`sample-32.s`和`sample.s`，找出它们的区别，并上网检索给出产生这些区别的原因。如：

- `pushq`和`pushl`
- `rsp`和`esp`

***

- 关于**后缀**方面的区别

     -  “q”和“l”是后缀，类似的还有“b”、“s”、“w”、“t”，其中
     - b代表一个8 bit
     - s代表16 bit整数或者32 bit浮点
     - w代表16 bit
     - l代表32 bit整数或者64 bit浮点
     - q代表64 bit
     - t代表80 bit浮点
     - 所以，32位汇编使用`pushl`，将一个32位的数据入栈，而64位汇编使用`pushq`，将一个64位的数据入栈，类似的还有`movel`和`moveq`、`popl`（leave等价的部分）和`popq`

- **寄存器**使用以及**栈**方面的区别

  - 64位有16个寄存器，长度为8byte,其中前八个分别为命名为rax,rbx,rcx,rdx,rsi,rdi,rbp,rsp（当然e开头的寄存器名还是可以用作表示对应寄存器的低32位）后八个为r8-r15,低位用d，w，b指定长度
  - 32位有8个寄存器，长度为4byte,分别为eax,ebx,eccx,edx,esi,edi,ebp,esp
  - 32位使用ebp作为栈帧指针，用这个指针可以直接存取堆栈中的数据，其作用是在函数调用时保存esp使函数结束时可以正确返回，在上述汇编程序中，栈指针esp可以变化，但ebp保持不变，一直指向栈帧的底部2。
  - 64位汇编不再有栈帧指针（ebp对应地rbp被作为通用寄存器使用），函数可以获取栈至多128字节的空间。这样函数就可以在不改变栈指针的情况下在栈内储存信息（即rsp以下的128字节的空间，被称为red zone）
  - 这也就是为什么32位汇编多了如下两条指令

  ```assembly
  subl    $16, %esp        #在栈顶分配16字节的空间
  
  movl 	%ebp,%esp 			 #将ebp的值放入esp，即将函数的起始地址返回到esp中
  ```

- CFI：调用框架指令方面的不同

  - CFA：标准框架地址，即**在前一个调用框架调用当前函数时的栈顶指针**

  - 32位汇编中

    ```assembly
    pushl   %ebp
    .cfi_def_cfa_offset 8
    .cfi_offset 5, -8
    movl    %esp, %ebp       .cfi_def_cfa_register 5
    #从这里开始，ebp作为计算CFA的基址寄存器
    ```

    64位汇编中

    ```assembly
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    ```

    二者`.cfi_def_cfa_offset`后面的值（偏移量）不同，表示此处举例CFA的地址不同(以64位为例,返回地址占了8byte,而`pushq %rbp`又入栈了8byte,故举例CFA16byte)，这是由于`pushq`和`pushl`的不同导致的，这也是后面`.cif_offset`不同的原因

    而且二者将CFA赋值给的寄存器也不同，32位赋值给5号寄存器`ebp`，64位赋值给6号寄存器`rbp`

    同时，同时,`.cfi_def_cfa_register 5`说明执行完`movl    %esp, %ebp   `后CFA的基址寄存器变味了ebp，64位同理

  - 32位汇编的末尾

    ```assembly
    .cfi_restore 5
    .cfi_def_cfa 4, 4
    ret
    ```

    将五号寄存器ebp恢复到函数开始的样子，再重新定义CFA，为第四号寄存器ebp所指的位置加四个字节（32位）

    64位汇编的末尾

    ```assembly
    .cfi_def_cfa 7, 8
    ret
    ```

    可见64位汇编不需要恢复5号寄存器，这是因为64位汇编中没有栈帧指针的规定，这里将CFA赋为7号寄存器rsp所指的位置增加8个字节（64位）

  

## **问题1-3** 你可以用`clang`替换`gcc`，重复上面的各步，比较使用`clang`和`gcc`分别输出的结果有何异同。

- 预处理的异同

     预处理的区别主要在于前面带`#`的部分,剩下的主要代码部分都是相同的

* 汇编的异同
  * 32位汇编
    * `.text`和`.file`顺序反过来了
    * `clang`生成的汇编代码中使用了`p2align`填充以在16字节边界上对齐
    * 二者跳转所用的标记符也不同
    * `clang`生成的代码中没有使用CFI框架
    * 在栈顶分配的空间也不同
    * `clang`生成的代码中多了一步`movl    $0, -4(%ebp)`,这一步在`gcc`生成的代码中没有,且在逻辑上没有用处,在后续的代码中也没有用到,这也导致了临时变量存储的位置也有所不同
    * 左移的具体实现有所不同,`gcc`生成的代码中直接使用了`sall`(算术左移)指令,而`clang`生成的代码中则是先将要左移的数据`movl`到`eax`中,然后再使用`shll`(逻辑左移)进行左移,再使用`movl`将数据放回原来的位置,在`jmp`跳转L3之前也有类似的区别
    * `gcc`生成的代码中返回值通过直接将0`movl`到`eax`中得到,而`clang`生成的代码中返回值通过`eax`与自身进行异或得到0
    * 释放栈顶空间的方式不同,`gcc`通过把之前保存的`ebp`的值放入`esp`中释放,而`clang`通过加操作使`esp`指针回退
    * `gcc`使用`ret`,而`clang`使用`retl`
    * 结尾部分也有所不同
    * 不管是`gcc`还是`clang`,整个代码的逻辑是相同的,未分析的指令基本都是相同的
  * 64位汇编
    * 在`clang`生成的64位汇编中使用了CFI框架,这一点和`gcc`相同
    * `gcc`中使用6号寄存器,`clang`直接指出是`rbp`寄存器,这是等价的,7号寄存器`rsp`也有类似的用法
    * `gcc`中使用ret,而`clang`中使用`retq`
    * 其余的不同点同32位汇编

* 反汇编

  和之前汇编部分的异同分析一致

* 全局/外部符号相同
  * 二者相同

* 直接调用连接器`ld`
  * 二者相同

## 参考

部分内容参考CSDN



